---
title: "Assignment 3"
author: "Tayyab Munir - 11716089"
date: "9/23/2020"
output:
  word_document: default
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)


```

## Question 1


```{r}

library("dplyr")


```



```{r}

msleep = read.csv("https://scads.eecs.wsu.edu/wp-content/uploads/2017/10/msleep_ggplot2.csv")


```

Before you begin, print the first few values of the columns with a header including “sleep”. (head(), head())

```{r}

head(msleep)


```

```{r}

head(select(msleep, starts_with("sleep")))

```

a. Count the number of animals which weigh under 1 kilogram and sleep more than 14 hours a day. (filter(), query())

```{r}

light_animals1 = msleep%>%
  select("name", "genus", "order", "sleep_total", "bodywt", "brainwt")%>%
  filter(bodywt<1 & sleep_total>14)
light_animals1

```

Number of animals: 14

```{r}
count(light_animals1)

```


```{r}
light_animals2 = msleep%>%
  select("name", "genus", "order", "sleep_total", "bodywt", "brainwt")%>%
  filter((bodywt+brainwt)<1 & sleep_total>14)
light_animals2


```
Number of animals(brainwt): 7
```{r}

count(light_animals2)


```
b. Print the name, order, sleep time and bodyweight of the animals with the 6 longest sleep times, in order of sleep time. (select(), arrange(), loc(), sort_values())
```{r}

msleep%>%
  select(name,order,sleep_total,bodywt)%>% 
  arrange(desc(sleep_total))%>%
  head()
  

```
c. Add two new columns to the dataframe; wt_ratio with the ratio of brain size to body weight, rem_ratio with the ratio of rem sleep to sleep time. If you think they might be useful, feel free to extract more features than these, and describe what they are. (mutate(), assign())
```{r}

new_msleep = msleep%>%
  mutate(
    wt_ratio = brainwt/bodywt,
    rem_ratio = sleep_rem/sleep_total,
    awake_ratio = awake/sleep_total,
    total_wt = brainwt+bodywt
  )
new_msleep

```

Description:
wt_ratio is Ratio of Brain Size and Body Weight
rem_ratio is Ratio of Rem sleep and Sleep Time
awake_ratio is Ratio of Awake Time and Sleep Time
total_wt is Body Weight plus Brain Weight

d. Display the average, min and max sleep times for each order. (group_by(), summarise(), groupby(), agg())
```{r}

animal_sleep_stats = msleep%>%
  group_by(order) %>%
  summarise(avg_sleep = mean(sleep_total), min_sleep = min(sleep_total), max_sleep = max(sleep_total), total = n())
animal_sleep_stats
```
e. Impute the missing brain weights as the average wt_ratio for that animal’s order times the animal’s weight. Make a second copy of your dataframe, but this time impute missing brain weights with the average brain weight for that animal’s order. What assumptions do these data filling methods make? Which is the best way to impute the data, or do you see a better way, and why? You may impute or remove other variables as you find appropriate. Briefly explain your decisions. (group_by(), mutate(), groupby(),assign())
```{r}

missing_average_weight_ratio = msleep%>%
  group_by(order)%>%
  mutate(brainwt = ifelse(is.na(brainwt), mean(brainwt / bodywt, na.rm = TRUE) * bodywt, brainwt))%>%
  ungroup()
missing_average_weight_ratio
```

```{r}

na.omit(missing_average_weight_ratio[,"brainwt"])

```
```{r}
missing_average_weight = msleep%>%
  group_by(order) %>%
  mutate(brainwt = ifelse(is.na(brainwt), mean(brainwt,na.rm = TRUE), brainwt))  %>%
  ungroup()
missing_average_weight
```


```{r}

na.omit(missing_average_weight[,"brainwt"])

```


```{r}

missing_sleep_rem = msleep%>%
  select("name","genus","vore","order","sleep_rem","sleep_cycle")%>%
  group_by(order)%>%
  mutate(sleep_rem=ifelse(is.na(sleep_rem),ifelse(is.nan(mean(sleep_rem, na.rm = TRUE)),0,mean(sleep_rem,na.rm = TRUE)),sleep_rem))%>%
  ungroup()
missing_sleep_rem
```



```{r}

missing_sleep_cycle = msleep%>%
  select("name","genus","vore","order","sleep_rem","sleep_cycle")%>%
  group_by(order)%>%
  mutate(sleep_cycle=ifelse(is.na(sleep_cycle),ifelse(is.nan(mean(sleep_cycle,na.rm = TRUE)),0,mean(sleep_cycle,na.rm = TRUE)),sleep_cycle))%>%
  ungroup()
missing_sleep_cycle
```

The best way to replace missing values is by taking the mean of the brain weight since replacing the mean will not affect the data when we perform statistical operations on it. Therefore the missing values of sleep_rem and sleep_cycle has been replaced by the corresponding mean of their orders.



## Question 2

For this question, you will first need to read section 12.6 in the R for Data Science book, here (http://r4ds.had.co.nz/tidy-data.html#case-study). Grab the dataset from the tidyr package (tidyr::who), and tidy it as shown in the case study before answering the following questions. Note: if you are using pandas you can perform these same operations, just replace the pivot_longer() function with melt() and the pivot_wider() function with pivot().
However, you may prefer to use R for this question, as the dataset is from an R package.


```{r}

library(tidyr)
who = tidyr::who

```
a. Explain why this line
      > mutate(key = stringr::str_replace(key, "newrel", "new_rel"))
is necessary to properly tidy the data. What happens if you skip this line?

This line is used to replace all the strings which contain newrel as column name to new_rel. This is done because when we try to separate the data using separate(key, c(“new”, “type”, “sexage”), sep = "_"), if we retain the column name as newrel itself, both the details of whether is a new case of TB (new) and the type of TB (rel) will both be present in the new column itself. If we change newrel to new_rel there will be consistency in all the column names which not only makes the separate function execute as expected other functions will also work as expected.
```{r}




```

b. How many entries are removed from the dataset when you set values_drop_na to true in the pivot_longer command (in this dataset)?


To check the number of entries that are removed from the dataset when we removed the NA values in the gather command, first let check how much entries were there before removing the NA’s.

```{r}

who1 = who %>% 
  gather(new_sp_m014:newrel_f65, key = "key", value = "cases", na.rm = FALSE)

who1

```
It shows that arround 405,440 entries are there in total having both numeric data for some entities and NA data for the rest. The following lines of codes shows the number of data left after removing NA from the data set.


```{r}

who1 = who %>% 
  gather(new_sp_m014:newrel_f65, key = "key", value = "cases", na.rm = TRUE)

who1

```
It shows that we had entries more than 300,000 that includes NA, and afteer removing that we are just left with 76 thousand entries.
If we were asked to do the same task without using na.rm = TRUE, I will use na.omit() to remove the rows having NA as input. It will give the same result arround 76 thousand rows.


```{r}

who1 = who %>% 
  gather(new_sp_m014:newrel_f65, key = "key", value = "cases")%>%
  na.omit(who1)

who1



```

I think that na.omit is a good way to handle these missing values from the dataset because na.rm is mostly used in mathematical operations whereas, na.omit is used to omit all the rows that contains missing value.

c. Explain the difference between an explicit and implicit missing value, in general. Can you find any implicit missing values in this dataset, if so where?

Explicit missing values means there is a specific representation that will indicate the row has missing value (row=NA)
Implicit missing values means the value is not present(row=" ") or might be represented differently (row = 0)


```{r}

whonew = who
implictCount=whonew %>%
  gather(new_sp_m014:newrel_f65, key = "key", value = "cases", na.rm = TRUE)%>%
  filter(cases == 0) %>%
  nrow()

whonew
```

Total Implicit Missing Value = 11080

d. Looking at the features (country, year, var, sex, age, cases) in the tidied data, are they all appropriately typed? Are there any features you think would be better suited as a different type? Why or why not?

```{r}
who_tidied_data=who %>%
  gather(key, value, new_sp_m014:newrel_f65, na.rm = TRUE) %>%
  mutate(key = stringr::str_replace(key, "newrel", "new_rel")) %>%
  separate(key, c("new", "var", "sexage")) %>%
  select(-new, -iso2, -iso3) %>%
  separate(sexage, c("sex", "age"), sep = 1)

who_tidied_data

```
```{r}

sapply(who_tidied_data, class)


```

The column age can be changed from character to integer since it contains only integer values.

e. Generate an informative visualization, which shows something about the data. Give a brief description of what it shows, and why you thought it would be interesting to investigate.

```{r}

library(ggplot2)


```
```{r}

library(ggpubr)


```


```{r}

who_v_is= who %>%
  gather(new_sp_m014:newrel_f65, key = "key", value = "cases", na.rm = TRUE)%>%
  mutate(key = stringr::str_replace(key, "newrel", "new_rel"))%>%
  separate(key, c("new", "type", "sexage"), sep = "_")%>%
  select(-new, -iso2, -iso3)%>%
  separate(sexage, c("sex", "age"), sep = 1)

country_cases=who_v_is%>%
group_by(country)%>%
tally(cases)%>%
top_n(5)
```
```{r}

ggplot(data=country_cases, aes(x=country,y=n))+
  geom_bar(stat="identity",width=0.5,fill="steelblue")+
  ggtitle("Top 5 Countries with TB")+
  xlab("Country")+ylab("Total")


```

The Above Graph Shows the countries with most TB cases. From the plot we can understand Asia and South Africa are the most affected.


```{r}

type_cases=who_v_is%>%
  group_by(type)%>%
  tally(cases)

ggplot(data=type_cases, aes(x=type,y=n))+
  geom_bar(stat="identity",width=0.5,fill="steelblue")+
  ggtitle("Types of Tuberculosis")+
  xlab("Type")+ylab("Total")
```


The Above Graph Shows the different types of TB. From the plot we can find that sp is the most common type of TB.

```{r}

year_cases=who_v_is%>%
  group_by(year)%>%
  tally(cases)%>%
  top_n(5)


```
```{r}

ggplot(data=year_cases, aes(x=year,y=n))+
  geom_bar(stat="identity",width=0.5,fill="steelblue")+
  ggtitle("Top 5 Years with most Tuberculosis Cases")+
  xlab("Year")+ylab("Total")


```


The Above Graph Shows the years with most TB cases. From the plot we can see that from 2007-2012 has seen the most TB cases and the number of TB cases in these years are almost same.

```{r}

sex_cases=who_v_is%>%
  group_by(sex)%>%
  tally(cases)

ggplot(data=sex_cases, aes(x=sex,y=n))+
  geom_bar(stat="identity",width=0.5,fill="steelblue")+
  ggtitle("Male vs Female Tuberculosis Cases")+
  xlab("Sex")+ylab("Total")

```


The Above Graph Shows the number of TB cases for men and women. From the plot we know that men are more
prone to TB when compared to women.



f. Suppose you have the following dataset called siteDemo:

You know that the U30.F column is the number of female users under 30 on the site, O30.M denotes the number of male users 30 or older on the site, etc. Construct this table, and show the code you would use to tidy this dataset (using gather()/pivot_longer() and separate()/pivot_wider() or melt() and pivot()) such that the columns are organized as:
Site, AgeGroup, Gender and Count.


```{r}

siteDemo = data.frame(Site = c("facebook", "myspace","snapchat","twitter","tiktok"),
                      U30.F = c(30,1,6,18,44),
                      U30_M = c(35,2,5,23,60),
                      O30.F = c(66,3,3,12,2),
                      O30.M = c(58,6,2,28,7))

siteDemo
```


```{r}

library(tidyr)

new_siteDemo = gather(siteDemo, key = "Age_Group", value = "Number_Of_Users", -Site)

new_siteDemo
```

```{r}

final_siteDemo = separate(new_siteDemo, col = Age_Group, into = c("Age Group", "Gender"), sep = "([\\.\\_])")

final_siteDemo
```



```
